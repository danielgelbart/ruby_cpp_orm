#include "dmmm_dbface.h"
#include "dmmm_utils.hpp"
using namespace mysqlpp;
using namespace std;
using namespace DMMM;

DBFace* DBFace::_this = NULL;

DBFace::DBFace(const string& database, const string& host, 
	       const string& user, const string& password)
    : _os(NULL)
{
    _this = this;
    if (!_connection.connect(database.c_str(), host.c_str(), 
			     user.c_str(), password.c_str()))
    {
	if (_os)
	    (*_os) << "Could not connect to DB";        
        cerr << "Could not connect to DB";
        exit(-1);
    }     
}

DBFace::DBFace(const string& database, const string& host, 
               const string& user, const string& password,
               ostream* os)
    : _os(os)
{
    _this = this;
    if (!_connection.connect(database.c_str(), host.c_str(), 
			     user.c_str(), password.c_str()))
    {
	if (_os)
	    (*_os) << "Could not connect to DB";
        cerr << "Could not connect to DB";
        exit(-1);
    }     
}

void
DBFace::log(const string& message)
{
    if (_os)
	(*_os) << "DMMM: " << message << endl;
}

void
DBFace::logError(const string& message)
{
    log(string("ERROR: ") + message);
}

bool
DBFace::select(const vector<string>& tables, 
	       const vector<string>& columns,
	       const string& where, 
	       const string& additional, 
	       QueryRes& rRes)
{
    boost::mutex::scoped_lock lock(_mutex);

    Query q = _connection.query();
    
    q << "SELECT ";
    for (size_t i = 0; i < columns.size(); ++i){
	if (i > 0)
	    q << ",";
	q << tables[0] << "." << columns[i];
    }
    q << " FROM " << tables[0];
    for (size_t i = 1; i < tables.size(); ++i)
        q << ", " + tables[i];
    if (where.size())
	q << " WHERE " << where;
    if (additional.size())
	q << " " << additional;
    log(q.str());
    StoreQueryResult mysqlRes;
    try{
	mysqlRes = q.store();
    }
    catch (const mysqlpp::Exception& er) {
	logError(er.what());
        return false;
    }
    
    for (size_t i = 0; i < mysqlRes.num_rows(); ++i){
	rRes.resize(rRes.size() + 1);
	for (size_t j = 0; j < columns.size(); ++j)
	    rRes.back()[columns[j]] = UTILS::toString(mysqlRes[i][columns[j].c_str()]);
    }
    return true;
}

size_t
DBFace::count(const vector<string>& tables, 
	      const string& where)
{
    boost::mutex::scoped_lock lock(_mutex);

    Query q = _connection.query();
    
    q << "SELECT count(*) as count FROM " << tables[0];
    for (size_t i = 1; i < tables.size(); ++i)
        q << ", " + tables[i];
    if (where.size())
	q << " WHERE " << where;
    log(q.str());
    StoreQueryResult mysqlRes;
    try{
	mysqlRes = q.store();
    }
    catch (const mysqlpp::Exception& er) {
	logError(er.what());
        return false;
    }

    if (mysqlRes.num_rows() == 1)
	return UTILS::fromString<size_t>(UTILS::toString(mysqlRes[0]["count"]));
    else
        return 0;    
}


bool 
DBFace::erase(const vector<string>& tables, 
   	      const string& where)
{
    Query q = _connection.query();
    q << "DELETE FROM " << tables[0];
    if (tables.size() > 1)
        q << " USING " + tables[0] + " ";
    for (size_t i = 1; i < tables.size(); ++i)
        q << " INNER JOIN " + tables[i];
    if (where.size())
	q << " WHERE " << where;
    log(q.str());
    return executeQuery(q);
    
}


bool
DBFace::executeQuery(Query& q)
{
    boost::mutex::scoped_lock lock(_mutex);
    try{
        q.execute();
    }
    catch (const mysqlpp::Exception& er) {
	logError(er.what());
        return false;
    }
    return true;
}

bool
DBFace::getLastInsertId(Query& rQuery, size_t& rId)
{
    try{
        rId = rQuery.insert_id();
    }
    catch (const mysqlpp::Exception& er) {
	logError(er.what());
        return false;
    }
    return true;
}

bool 
DBFace::insert(const string& table, 
	       const map<string, string>& field2Val,
	       size_t& rInsertId)
{
    if (field2Val.size() == 0)
	return true;

    Query q = _connection.query();
    q << "INSERT INTO " << table << " (";
    for (map<string, string>::const_iterator it = field2Val.begin(); 
	 it != field2Val.end(); ++it)
    {
	if (it != field2Val.begin())
	    q << ",";
	q << it->first;
    }
    q << ")VALUES(";
    for (map<string, string>::const_iterator it = field2Val.begin(); 
	 it != field2Val.end(); ++it)
    {
	if (it != field2Val.begin())
	    q << ",";
	q << quote << it->second;
    }
    q << ")";
    log(q.str());
    bool ok = executeQuery(q);
    ok = ok && getLastInsertId(q, rInsertId);
    return ok;
}

bool
DBFace::update(const string& table, 
	       const map<string, string>& field2Val,
	       const string& where)
{
    Query q = _connection.query();
    
    q << "UPDATE " << table << " SET ";
    for (map<string, string>::const_iterator it = field2Val.begin();
	 it != field2Val.end(); ++it)
    {
	if (it != field2Val.begin())
	    q << ",";
	q << it->first << "=" << quote << it->second;
    }
    if (where.size())
	q << " WHERE " << where;
    log(q.str());
    return executeQuery(q);
}

string 
DBFace::now()
{
    Query q = _connection.query();
    
    q << "SELECT NOW()";
    StoreQueryResult mysqlRes;
    try{
	mysqlRes = q.store();
    }
    catch (const mysqlpp::Exception& er) {
        cerr << "Query failed: " << q << endl << er.what();
        return string();
    }
    return UTILS::toString(mysqlRes[0]["now()"]);
}
