<% class_name = self.name %>
<% all_caps_name = class_name.upcase %>
#ifndef O_<%= all_caps_name %>
#define O_<%= all_caps_name %>

#include <map>
#include <string>
#include "dmmm_utils.hpp"
#include "dmmm_dbface.h"
#include "dmmm_identifiers.hpp"
#include "dmmm_fields.hpp"
#include "dmmm_comparators.hpp"
<% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::ManyToOne::Relationship'}.each do |relative| %>
#include "T_<%= relative[0].to_const_string %>.hpp"
<% end %>
namespace DMMM {

class O_<%= class_name %>{
public:
    <% generated_properties.each do |property| %>
    const F_<%= property.class.primitive %>::Base& _<%= property.name %>() const { 
        return _f_<%= property.name %>._base; 
    }
    F_<%= property.class.primitive %>::Base& _<%= property.name %>() { 
        _f_<%= property.class.primitive %>._dirty = true; 
        return _f_<%= property.name %>._base; 
    }

    <% end %>

    <% if serial %>
    bool update(){
        std::map<std::string, std::string> field2Val;
        <% generated_properties.each do |property| %>
        if (_f_<%= property.name %>._dirty)
            field2Val["<%= property.name %>"] = 
                toString(_f_<%= property.name %>._base);
        <% end %>
        std::string where =
	    "<%= serial.name %>=" + toString(_f_<%= serial.name %>._base);
        return DBFace::instance()->update("<%= storage_name %>", 
                                          field2Val, where);
    }
    <% end %>


    bool insert(){
        std::map<std::string, std::string> field2Val;
        <% generated_properties.each do |property| %>
        if (_f_<%= property.name %>._dirty)
            field2Val["<%= property.name %>"] = 
                toString(_f_<%= property.name %>._base);
        <% end %>
        return DBFace::instance()->insert("<%= storage_name %>", field2Val);
    }
/*
    <% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::ManyToOne::Relationship'}.each do |relative| %>
    std::pair<O_<%= relative[0].to_const_string %>, bool> <%= relative[0] %>(){
        return T_<%= relative[0].to_const_string %>::first(E_<%= serial.name %> == _f_
    }
    <% end %>
*/

private:
    <% generated_properties.each do |property| %>
        F_<%= property.class.primitive %> _f_<%= property.name %>;
    <% end %>


    friend class T_<%= class_name %>;
};

}; //namespace DMMM
#endif //O_<%= all_caps_name %>
