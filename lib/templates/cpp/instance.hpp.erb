<% class_name = self.name %>
<% all_caps_name = class_name.upcase %>
#ifndef O_<%= all_caps_name %>
#define O_<%= all_caps_name %>

#include <map>
#include <string>
#include "dmmm_utils.hpp"
#include "dmmm_dbface.h"
#include "dmmm_identifiers.hpp"
#include "dmmm_fields.hpp"
#include "dmmm_comparators.hpp"
<% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::ManyToOne::Relationship'}.each do |relative| %>
#include "T_<%= relative[1].parent_model.to_s %>.hpp"
<% end %>

<%# self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::OneToMany::Relationship'}.each do |relative| %>
<%# end %>
namespace DMMM {

class O_<%= class_name %>{
public:
    <% generated_properties.each do |property| %>
    const <%= property.instance_variable_get(:@cpp_name) %>::Base& _<%= property.name %>() const { 
        return _f_<%= property.name %>._base; 
    }
    <%= property.instance_variable_get(:@cpp_name) %>::Base& _<%= property.name %>() { 
        _f_<%= property.name %>._dirty = true; 
        return _f_<%= property.name %>._base; 
    }

    <% end %>

    <% if serial %>
    bool update(){
        std::map<std::string, std::string> field2Val;
        <% generated_properties.each do |property| %>
        if (_f_<%= property.name %>._dirty)
            field2Val["<%= property.name %>"] = 
                toString(_f_<%= property.name %>._base);
        <% end %>
        std::string where =
	    "<%= serial.name %>=" + toString(_f_<%= serial.name %>._base);
        return DBFace::instance()->update("<%= storage_name %>", 
                                          field2Val, where);
    }

    <% end %>


    bool insert(){
        std::map<std::string, std::string> field2Val;
        <% generated_properties.each do |property| %>
        if (_f_<%= property.name %>._dirty)
            field2Val["<%= property.name %>"] = 
                toString(_f_<%= property.name %>._base);
        <% end %>
        <% if serial %>
        return DBFace::instance()->
            insert("<%= storage_name %>", field2Val,
                   _f_<%= serial.name %>._base.serialization());
	<% else %>
        size_t id;
        return DBFace::instance()->
            insert("<%= storage_name %>", field2Val,
                   id);
        <% end %>
 				   
    }

    <% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::ManyToOne::Relationship'}.each do |r| %> 
    <% parent = r[0].to_const_string %>
    std::pair<O_<%= parent %>, bool> <%= r[0] %>(){
        T_<%= parent %>_Constrained T(T_<%= parent %>::E_<%= r[1].parent_key.first.name.to_s %>() == _<%= r[1].child_key.first.name.to_s %>());
	return T.first();
    }
    <% end %>

/*
    <% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::OneToMany::Relationship'}.each do |r| %> 
    <% child = r[0].to_const_string %>
    T_<%= child %>_Constrained <%= r[0] %>(){
        return T_<%= child %>_Constrained(E_<%= r[1].child_key.first.name.to_s %> == _f_<%= r[1].parent_key.first.name.to_s %>);
    }
    <% end %>
*/

private:
    <% generated_properties.each do |property| %>
    <%= property.instance_variable_get(:@cpp_name) %> _f_<%= property.name %>;
    <% end %>


    friend class T_<%= class_name %>;
};

} //namespace DMMM
#endif //O_<%= all_caps_name %>
