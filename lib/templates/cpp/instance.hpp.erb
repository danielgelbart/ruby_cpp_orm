<% class_name = self.name %>
<% all_caps_name = class_name.upcase %>
#ifndef O_<%= all_caps_name %>
#define O_<%= all_caps_name %>

#include <map>
#include <string>
#include "dmmm_utils.hpp"
#include "dmmm_dbface.h"
#include "dmmm_identifiers.hpp"
#include "dmmm_fields.hpp"
#include "dmmm_comparators.hpp"
<% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::ManyToOne::Relationship'}.each do |relative| %>
#include "T_<%= relative[0].to_const_string %>.hpp"
<% end %>
namespace DMMM {

class O_<%= class_name %>{
public:
    <% generated_properties.each do |property| %>
    const F_<%= property.class.primitive %>::Base& _<%= property.name %>() const { 
        return _f_<%= property.name %>._base; 
    }
    F_<%= property.class.primitive %>::Base& _<%= property.name %>() { 
        _f_<%= property.class.primitive %>._dirty = true; 
        return _f_<%= property.name %>._base; 
    }

    <% end %>

    <% if serial %>
    bool update(){
        std::map<std::string, std::string> field2Val;
        <% generated_properties.each do |property| %>
        if (_f_<%= property.name %>._dirty)
            field2Val["<%= property.name %>"] = 
                toString(_f_<%= property.name %>._base);
        <% end %>
        std::string where =
	    "<%= serial.name %>=" + toString(_f_<%= serial.name %>._base);
        return DBFace::instance()->update("<%= storage_name %>", 
                                          field2Val, where);
    }

    size_t id() { return _<%= serial.name %>; }
    <% end %>


    bool insert(){
        std::map<std::string, std::string> field2Val;
        <% generated_properties.each do |property| %>
        if (_f_<%= property.name %>._dirty)
            field2Val["<%= property.name %>"] = 
                toString(_f_<%= property.name %>._base);
        <% end %>
        return DBFace::instance()->insert("<%= storage_name %>", field2Val);
    }

    <% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::ManyToOne::Relationship'}.each do |r| %> 
    <% parent = r[0].to_const_string %>
    std::pair<O_<%= parent %>, bool> <%= r[0] %>(){
        T_<%= parent %>_Constrained T(E_<%= r[1].parent_key.first.name.to_s %> == _f_<%= r[1].child_key.first.name.to_s %>);
	return T.first();
    }
    <% end %>

    <% self.relationships.select{|r,m| m.class.name == 'DataMapper::Associations::OneToMany::Relationship'}.each do |r| %> 
    <% child = r[0].to_const_string %>
    T_<%= child %>_Constrained <%= r[0] %>(){
        return T_<%= child %>_Constrained(E_<%= r[1].child_key.first.name.to_s %> == _f_<%= r[1].parent_key.first.name.to_s %>);
    }
    <% end %>


private:
    <% generated_properties.each do |property| %>
        F_<%= property.class.primitive %> _f_<%= property.name %>;
    <% end %>


    friend class T_<%= class_name %>;
};

}; //namespace DMMM
#endif //O_<%= all_caps_name %>
