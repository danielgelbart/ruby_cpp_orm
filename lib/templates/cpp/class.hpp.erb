<% class_name = self.name %>
<% all_caps_name = class_name.upcase %>
#ifndef T_<%= all_caps_name %>
#define T_<%= all_caps_name %>
#include "O_<%= class_name %>.hpp"
namespace DMMM {

class T_<%= class_name %>{
public:
    struct Condition{
        std::string _cond;
    };
    
    <% generated_properties.each do |property| %>
    struct E_<%= property.name %>{
        E_<%= property.name %>() { _field = "<%= property.name %>" ;}
        std::string _field;
        typedef T_<%= class_name %>::Condition ConditionType;
        typedef <%= property.instance_variable_get(:@cpp_name) %>::Base ComparerType;
    };

    static E_<%= property.name %> _<%= property.name %>(){ 
        return E_<%= property.name %>();
    }

    <% end %>    

    static void getFields(std::vector<std::string>& rFields)
    {
        rFields.clear();
        <% generated_properties.each do |property| %>
        rFields.push_back("<%= property.name %>");
        <% end %>
    }

    static void select(const Condition& c, 
                       const std::string& additional,
                       std::vector<O_<%= class_name %>>& r)
    {
        std::vector<std::string> fields;
        getFields(fields);
        QueryRes res;
        DBFace::instance()->select("<%= storage_name %>",
                                   fields, c._cond, additional, res);
        r.resize(res.size());
        for(size_t i = 0; i < res.size(); ++i){
            <% generated_properties.each do |property| %>
            r[i]._f_<%= property.name %>._base = 
                fromString<<%= property.instance_variable_get(:@cpp_name) %>::Base>(res[i]["<%= property.name %>"]);
            <% end %>
        }
    }

    static void select(const Condition& c, 
                       std::vector<O_<%= class_name %>>& r)
    {
        select(c, "", r);
    }

    static std::pair<O_<%= class_name %>, bool> first(const Condition& c){
        std::vector<O_<%= class_name %>> r;
        select(c, "limit 1", r);
        if(r.size() > 0)
            return std::make_pair(r[0], true);
        else
            return std::make_pair(O_<%= class_name %>(), false);
    }

    static std::pair<O_<%= class_name %>, bool> first(){
        return first(Condition());
    }

};


class T_<%= class_name %>_Constrained : public T_<%= class_name %>{

public:
    void select(const Condition& c, 
                       const std::string& additional,
                       std::vector<O_<%= class_name %>>& r)
    {		      
        T_<%= class_name %>::select(c && _constraint, additional, r);
    }
    std::pair<O_<%= class_name %>, bool> first(const Condition& c){
        return T_<%= class_name %>::first(c && _constraint);
    }    
    std::pair<O_<%= class_name %>, bool> first(){
        return T_<%= class_name %>::first(_constraint);
    }

    T_<%= class_name %>_Constrained(const Condition& c) : _constraint(c) {}

private:
    Condition   _constraint;    

};

}; //namespace DMMM
#endif //T_<%= all_caps_name %>
